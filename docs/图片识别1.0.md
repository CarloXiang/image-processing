#接口1.0

##说明
method:post

测试域名：180.76.143.82:3002
正式域名：180.76.143.82

##修改订单状态 
appid = youyuan
key = N6AG2WHLH74S5WC5
msg_encrypt=Base64_Encode(AES_Encrypt(orders))
sign=md5(timestamp+msg_encrypt)

request:
{"appid":"","sign":"","timestamp":1234566,"base64":""}

response:
{"retcode":0,"retmsg":"成功"}




##加密解密Demo
```php
class Aes
{
	/**
	 * AES加密
	 * @param string $decrypted_data
	 * @param string $secret_key
	 * @param string $iv
	 * @return string|null
	 */
	public static function encrypt($decrypted_data, $secret_key, $iv)
	{
		if (empty($secret_key) || strlen($iv) < 16)
		{
			return null;
		}
		$blocksize      = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
		$padded_data    = Aes::pkcs5_pad($decrypted_data, $blocksize);
		$encrypted      = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $secret_key, $padded_data, MCRYPT_MODE_CBC, $iv);
		$encrypted_data = base64_encode($encrypted);
		return $encrypted_data;
	}

	/**
	 * AES解密
	 * @param string $encrypted_data
	 * @param string $secret_key
	 * @param string $iv
	 * @return string|null
	 */
	public static function decrypt($encrypted_data, $secret_key, $iv)
	{
		if (empty($secret_key) || strlen($iv) < 16)
		{
			return null;
		}
		$encrypted_data = base64_decode($encrypted_data);
		$decrypted      = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $secret_key, $encrypted_data, MCRYPT_MODE_CBC, $iv);
		$decrypted_data = Aes::pkcs5_unpad($decrypted, "\0");
		return $decrypted_data;
	}

	/**
	 * 采用pkcs5pad方式填充数据
	 * @param type $text
	 * @param type $blocksize
	 * @return type
	 */
	public static function pkcs5_pad($text, $blocksize)
	{
		$pad = $blocksize - (strlen($text) % $blocksize);
		return $text . str_repeat(chr($pad), $pad);
	}

	/**
	 * 删除多余的填充数据
	 * @param type $text
	 * @return boolean
	 */
	public static function pkcs5_unpad($text)
	{
		$pad = ord($text{strlen($text) - 1});
		if ($pad > strlen($text))
		{
			return false;
		}
		if (strspn($text, chr($pad), strlen($text) - $pad) != $pad)
		{
			return false;
		}
		return substr($text, 0, -1 * $pad);
	}
}
```

```java
import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class AESPlus {

    /**
     * 加密
     *
     * @param strKey 密匙
     * @param strIn  待加密串
     * @return
     * @throws Exception
     */
    public static String encrypt(String strKey, String strIn) {
        try {
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(
                    Cipher.ENCRYPT_MODE,
                    new SecretKeySpec(strKey.getBytes(), "AES"),
                    new IvParameterSpec(new byte[16])//初始化16空字节
            );

            byte[] encrypted = cipher.doFinal(strIn.getBytes());

            return new BASE64Encoder().encode(encrypted);
        } catch (Exception e) {
            System.out.println(e);
            return "";
        }
    }

    /**
     * 解密
     * @param strKey 密匙
     * @param strIn 待解密密串
     * @return
     */
    public static String decrypt(String strKey, String strIn){
        try
        {
            byte[] encrypted1 = new BASE64Decoder().decodeBuffer(strIn);

            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            SecretKeySpec keyspec = new SecretKeySpec(strKey.getBytes(), "AES");
            IvParameterSpec ivspec = new IvParameterSpec(new byte[16]);

            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            byte[] original = cipher.doFinal(encrypted1);
            String originalString = new String(original);
            return originalString;
        }
        catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
```